
#### Aim of prog: Gathering tool functions, note that the required packages are not loaded here
## Table of Contents
#	- lazyTrace: Bayesplot is having troubles on my mac (Arial font not always found), so I create my own traces plot
#	- lazyPosterior: Function to plot the prior and posterior of a parameter
#	- dbh_timeSeries: Function to plot latent dbh states time series (posteriorSim is generated by the centralised function)
#
## Comments
# This R file contains tool functions only that help me to analyse the results and do some check-up. Note that some functions are quite
#	similar to bayesplot, but I use base plot rather than ggplot. Moreover, Bayesplot is having troubles on my mac (Arial font not always
#	found), so I created my own traces and posterior plots.

## Bayesplot is having troubles on my mac (Arial font not always found), so I create my own traces plot
lazyTrace = function(draws, filename = NULL, ...)
{
	if (!is.array(draws) && !all(class(draws) %in% c("draws_array", "draws", "array")))
		stop("The class of draws should be either array, or compatible with cmdstanr (draws_array, draws, array)")
	
	n_chains = dim(draws)[2]
	n_iter = dim(draws)[1]
	colours = MetBrewer::met.brewer("Hokusai3", n_chains)
	colours_str = grDevices::colorRampPalette(colours)(n_chains)

	min_val = min(draws)
	max_val = max(draws)

	providedArgs = list(...)
	nbArgs = length(providedArgs)

	ls_names = names(providedArgs)

	val_ind = stri_detect(str = ls_names, regex = "val[[:digit:]]")
	xlab_ind = (ls_names == "xlab")
	ylab_ind = (ls_names == "ylab")
	main_ind = (ls_names == "main")
	label_ind = stri_detect(str = ls_names, regex = "label")
	iter_ind = stri_detect(str = ls_names, regex = "iter[[:digit:]]")

	scaling_ind = (ls_names == "scaling")
	if (any(scaling_ind)) scaling = providedArgs[["scaling"]] else scaling = 1

	if (any(label_ind))
		par(mar = c(5, 4, 4, 4))
	
	# Plot
	if (!is.null(filename))
	{
		pdf(paste0(filename, ".pdf"))
		print(paste0("Figure saved under the name: ", filename, ".pdf"))
	}
	
	plot(0, pch = "", xlim = c(0, n_iter), ylim = scaling*c(min_val, max_val), axes = TRUE, bg = "transparent",
		xlab = ifelse(any(xlab_ind), providedArgs[["xlab"]], ""),
		ylab = ifelse(any(ylab_ind), providedArgs[["ylab"]], ""),
		main = ifelse(any(main_ind), providedArgs[["main"]], ""))

	for (chain in 1:n_chains)
	{
		if (all(class(draws) %in% c("draws_array", "draws", "array")))
			lines(1:n_iter, scaling*draws[, chain,], type = "l", col = colours_str[chain])
		if (is.array(draws) && !all(class(draws) %in% c("draws_array", "draws", "array")))
			lines(1:n_iter, scaling*draws[, chain], type = "l", col = colours_str[chain])
	}

	if (any(val_ind))
	{
		for (val in ls_names[val_ind])
			abline(h = scaling*providedArgs[[val]], col = "#CD212A", lwd = 4)
		
		if (any(label_ind))
		{
			num_vals = stri_sub(str = ls_names[val_ind], from = stri_locate(str = ls_names[val_ind], regex = "val")[, "end"] + 1)
			for (label in ls_names[label_ind])
			{
				num_label = stri_sub(str = label, from = stri_locate(str = label, regex = "label")[, "end"] + 1)
				corresponding_val = (ls_names[val_ind])[num_vals == num_label]
				axis(4, at = scaling*providedArgs[[corresponding_val]], providedArgs[[label]], las = 1)
			}
		}
	}

	if (any(iter_ind))
	{
		for (iter in ls_names[iter_ind])
			abline(v = providedArgs[[iter]], col = "#66666644", lwd = 0.2)
	}

	if (!is.null(filename))
		dev.off()
}

## Function to plot the prior and posterior of a parameter
lazyPosterior = function(draws, fun = dnorm, expand_bounds = FALSE, filename = NULL, ...)
{
	# Check-up
	if (!is.array(draws))
		stop("Draws should be an array extracted from a CmdStanMCMC object")
		
	# isFALSE will not work here, hence !isTRUE
	if (!is.null(fun))
	{
		if (!isTRUE(all.equal(fun, dnorm)) &&
			!isTRUE(all.equal(fun, dlnorm)) &&
			!isTRUE(all.equal(fun, dgamma)) &&
			!isTRUE(all.equal(fun, dbeta)))
		{
			stop("This function only accepts dnorm, dlnorm, dgamma, or dbeta as priors")
		}
	}

	# Get list of arguments
	providedArgs = list(...)
	ls_names = names(providedArgs)
	nbArgs = length(providedArgs)

	# Get the argument for density if provided
	n = 512
	n_ind = (ls_names == "n")
	if (any(n_ind))
	{
		n = providedArgs[["n"]]
		print(paste0("Using n = ", n, " for the density plot"))
	}

	# Get the parameter's name if provided
	params = ""
	params_ind = (ls_names == "params")
	if (any(params_ind))
		params = providedArgs[["params"]]

	# Get the index of the x-axis label
	xlab_ind = (ls_names == "xlab")

	# Get the index of x values if any
	val_ind = stri_detect(str = ls_names, regex = "val[[:digit:]]")

	# Get the scaling on the x-axis if provided
	scaling_ind = (ls_names == "scaling")
	if (any(scaling_ind)) scaling = providedArgs[["scaling"]] else scaling = 1

	# Get parameters for prior
	if (isTRUE(all.equal(fun, dnorm)))
	{
		if ((!all(c("mean", "sd") %in% names(providedArgs))) && (!all(c("arg1", "arg2") %in% names(providedArgs))))
			stop("You must provide mean and sd for dnorm")
		
		if (all(c("mean", "sd") %in% names(providedArgs)))
		{
			arg1 = scaling*providedArgs[["mean"]]
			arg2 = scaling*providedArgs[["sd"]]
		} else {
			arg1 = scaling*providedArgs[["arg1"]]
			arg2 = scaling*providedArgs[["arg2"]]
		}
	}

	if (isTRUE(all.equal(fun, dlnorm)))
	{
		if ((!all(c("mean", "sd") %in% names(providedArgs))) && (!all(c("arg1", "arg2") %in% names(providedArgs))) &&
			(!all(c("meanlog", "sdlog") %in% names(providedArgs))))
			stop("You must provide mean and sd or meanlog and sdlog for dlnorm")
		
		if (all(c("mean", "sd") %in% names(providedArgs)))
		{
			dlnorm_mean = providedArgs[["mean"]]
			dlnorm_sd = providedArgs[["sd"]]

			arg1 = log(dlnorm_mean^2/sqrt(dlnorm_sd^2 + dlnorm_mean^2)) - log(scaling)
			arg2 = sqrt(log(dlnorm_sd^2/dlnorm_mean^2 + 1))
		} else if (all(c("meanlog", "sdlog") %in% names(providedArgs))) {
			arg1 = providedArgs[["meanlog"]] - log(scaling)
			arg2 = providedArgs[["sdlog"]]
		} else {
			print("args 1 and 2 provided; it is assumed they are meanlog and sdlog")
			arg1 = providedArgs[["arg1"]] - log(scaling)
			arg2 = providedArgs[["arg2"]]
		}
	}

	if (isTRUE(all.equal(fun, dgamma)))
	{
		if ((!all(c("mean", "var") %in% names(providedArgs))) && (!all(c("shape", "rate") %in% names(providedArgs)))
			&& (!all(c("arg1", "arg2") %in% names(providedArgs))))
			stop("You must provide either mean and var or shape and rate for dgamma")
		
		if (all(c("mean", "var") %in% names(providedArgs)))
		{
			temp1 = providedArgs[["mean"]]
			temp2 = providedArgs[["var"]] # Squared because in this case it is a variance, not a std. dev.

			arg1 = temp1^2/temp2 # shape
			arg2 = temp1/(temp2*scaling) # rate
		}

		if (all(c("shape", "rate") %in% names(providedArgs)))
		{
			arg1 = providedArgs[["shape"]]
			arg2 = providedArgs[["rate"]]/scaling
		}

		if (all(c("arg1", "arg2") %in% names(providedArgs)))
		{
			print("args 1 and 2 provided; it is assumed they are shape and rate")
			arg1 = providedArgs[["arg1"]]
			arg2 = providedArgs[["arg2"]]/scaling
		}
	}

	if (isTRUE(all.equal(fun, dbeta)))
	{
		if ((!all(c("mean", "var") %in% names(providedArgs))) && (!all(c("shape1", "shape2") %in% names(providedArgs)))
			&& (!all(c("arg1", "arg2") %in% names(providedArgs))))
			stop("You must provide either mean and var or shape1 and shape2 for dbeta")

		if (scaling != 1)
			warning("I have not coded the scaling for the beta distribution. Your plot might be out of the window")
		
		if (all(c("mean", "var") %in% names(providedArgs)))
		{
			temp1 = providedArgs[["mean"]]
			temp2 = providedArgs[["var"]]

			arg1 = ((1 - temp1)/temp2 - 1/temp1)*temp1^2 # shape 1
			arg2 = arg1*(1/temp1 - 1) # shape 2
		}

		if (all(c("shape1", "shape2") %in% names(providedArgs)))
		{
			arg1 = providedArgs[["shape1"]]
			arg2 = providedArgs[["shape2"]]
		}

		if (all(c("arg1", "arg2") %in% names(providedArgs)))
		{
			print("args 1 and 2 provided; it is assumed they are shape1 and shape2")
			arg1 = providedArgs[["shape1"]]
			arg2 = providedArgs[["shape2"]]
		}

		max_y_prior = optimise(f = fun, interval = c(0, 1), maximum = TRUE, shape1 = arg1, shape2 = arg2)[["objective"]]
	}

	# Get posterior
	density_from_draws = density(draws, n = n)
	x = density_from_draws$x
	y = density_from_draws$y
	min_x = min(x)
	max_x = max(x)
	max_y = max(y)


	min_x = ifelse (min_x < 0, 1.1*min_x, 0.9*min_x) # To extend 10% from min_x
	max_x = ifelse (max_x < 0, 0.9*max_x, 1.1*max_x) # To extend 10% from max_x

	if (isTRUE(all.equal(fun, dnorm)))
	{
		max_y_prior = optimise(f = fun, interval = c(min_x, max_x), maximum = TRUE, mean = arg1, sd = arg2)[["objective"]]
		if (expand_bounds)
		{
			check_min_bound = integrate(fun, lower = ifelse (min_x < 0, 10*min_x, -10*min_x), upper = min_x, mean = arg1, sd = arg2,
				subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			while (check_min_bound$value > 0.1)
			{
				min_x = ifelse (min_x < 0, 1.1*min_x, 0.9*min_x) # To extend 10% from min_x
				check_min_bound = integrate(fun, lower = ifelse (min_x < 0, 10*min_x, -10*min_x), upper = min_x, mean = arg1, sd = arg2,
					subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			}

			check_max_bound = integrate(fun, lower = max_x, upper = ifelse (max_x < 0, -10*max_x, 10*max_x), mean = arg1, sd = arg2,
				subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			while (check_max_bound$value > 0.1)
			{
				max_x = ifelse (max_x < 0, 0.9*max_x, 1.1*max_x) # To extend 10% from max_x
				check_max_bound = integrate(fun, lower = max_x, upper = ifelse (max_x < 0, -10*max_x, 10*max_x), mean = arg1, sd = arg2,
					subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			}
		}
	}

	if (isTRUE(all.equal(fun, dlnorm)))
	{
		max_y_prior = optimise(f = fun, interval = c(min_x, max_x), maximum = TRUE, meanlog = arg1, sdlog = arg2)[["objective"]]
		if (expand_bounds)
		{
			check_min_bound = integrate(fun, lower = ifelse (min_x < 0, 10*min_x, -10*min_x), upper = min_x, meanlog = arg1,
				sdlog = arg2, subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			while (check_min_bound$value > 0.1)
			{
				min_x = ifelse (min_x < 0, 1.1*min_x, 0.9*min_x) # To extend 10% from min_x
				check_min_bound = integrate(fun, lower = ifelse (min_x < 0, 10*min_x, -10*min_x), upper = min_x, meanlog = arg1,
					sdlog = arg2, subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			}

			check_max_bound = integrate(fun, lower = max_x, upper = ifelse (max_x < 0, -10*max_x, 10*max_x), meanlog = arg1,
				sdlog = arg2, subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			while (check_max_bound$value > 0.1)
			{
				max_x = ifelse (max_x < 0, 0.9*max_x, 1.1*max_x) # To extend 10% from max_x
				check_max_bound = integrate(fun, lower = max_x, upper = ifelse (max_x < 0, -10*max_x, 10*max_x), meanlog = arg1,
					sdlog = arg2, subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			}
		}
	}

	if (isTRUE(all.equal(fun, dgamma)))
	{
		max_y_prior = optimise(f = fun, interval = c(min_x, max_x), maximum = TRUE, shape = arg1, rate = arg2)[["objective"]]
		if (expand_bounds)
		{
			check_min_bound = integrate(fun, lower = ifelse (min_x < 0, 10*min_x, -10*min_x), upper = min_x, shape = arg1, rate = arg2,
				subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			while (check_min_bound$value > 0.1)
			{
				min_x = ifelse (min_x < 0, 1.1*min_x, 0.9*min_x) # To extend 10% from min_x
				check_min_bound = integrate(fun, lower = ifelse (min_x < 0, 10*min_x, -10*min_x), upper = min_x, shape = arg1, rate = arg2,
					subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			}

			check_max_bound = integrate(fun, lower = max_x, upper = ifelse (max_x < 0, -10*max_x, 10*max_x), shape = arg1, rate = arg2,
				subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			while (check_max_bound$value > 0.1)
			{
				max_x = ifelse (max_x < 0, 0.9*max_x, 1.1*max_x) # To extend 10% from max_x
				check_max_bound = integrate(fun, lower = max_x, upper = ifelse (max_x < 0, -10*max_x, 10*max_x), shape = arg1, rate = arg2,
					subdivisions = 2000, rel.tol = .Machine$double.eps^0.1)
			}
		}
	}
	if (!is.null(fun))
		max_y = max(max_y, max_y_prior)
	max_y = ifelse (max_y < 0, 0.9*max_y, 1.1*max_y) # To extend 10% from max_y

	# Plot
	if (!is.null(filename))
	{
		filename = paste0(filename, ".pdf")
		pdf(filename)
		print(paste0("Figure saved under the name: ", filename))
	}
	
	# Plot posterior
	plot(density_from_draws, xlim = c(min_x, max_x), col = "#295384", lwd = 2, main = paste("Prior and posterior", params))
	polygon(density_from_draws, col = "#29538466")

	# Plot prior
	if (!is.null(fun))
	{
		curve(fun(x, arg1, arg2), add = TRUE, lwd = 2, col = "#F4C430")
		DescTools::Shade(fun(x, arg1, arg2), breaks = c(min_x, max_x), col = "#F4C43066", density = NA)

		# Add legend
		legend(x = "topright", legend = c("Prior", "Posterior"), fill = c("#F4C430", "#295384"), box.lwd = 0)
	} else {
		legend(x = "topright", legend = "Posterior", fill = "#295384", box.lwd = 0)
	}

	# Add values
	if (any(val_ind))
	{
		for (val in ls_names[val_ind])
			abline(v = scaling*providedArgs[[val]], col = "#CD212A", lwd = 4)
	}

	if (!is.null(filename))
		dev.off()

	if (!is.null(fun))
		return(list(arg1 = arg1, arg2 = arg2, min_x = min_x, max_x = max_x, max_y = max_y, max_y_prior = max_y_prior, filename = filename))
		
	return(list(min_x = min_x, max_x = max_x, max_y = max_y, filename = filename))
}
